<!doctype html>
	<html>
	<head>
	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-151395790-1"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'UA-151395790-1');
	</script>	
	<title>MergeTwoBinaryTrees</title>
	<!-- Latest compiled and minified CSS -->
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu" crossorigin="anonymous">

	<!-- Optional theme -->
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap-theme.min.css" integrity="sha384-6pzBo3FDv/PJ8r2KRkGHifhEocL+1X2rVCTTkUfGk7/0pbek5mMa1upzvWbrUbOZ" crossorigin="anonymous">

	<!-- Latest compiled and minified JavaScript -->
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd" crossorigin="anonymous"></script>

	<link rel="stylesheet" href="../web/codepage.css" />
	</head>
	<body>
	<h1>MergeTwoBinaryTrees</h1>
	
	<figure class="highlight">
	<pre>
	<code class="language-html">
#include "stdafx.h"

//You are given two binary trees root1 and root2.
//Imagine that when you put one of them to cover the other, some nodes of the two
//trees are overlapped while the others are not. You need to merge the two trees
//into a new binary tree. The merge rule is that if two nodes overlap, then sum
//node values up as the new value of the merged node. Otherwise, the NOT null
//node will be used as the node of the new tree.
//Return the merged tree.
//
//Note: The merging process must start from the root nodes of both trees.
// 
//
//Example 1:
//Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
//Output: [3,4,5,5,4,null,7]
//
//Example 2:
//Input: root1 = [1], root2 = [1,2]
//Output: [2,2]
// 
//Constraints:
//The number of nodes in both trees is in the range [0, 2000].
//-104 &lt;= Node.val &lt;= 104
namespace Solution2022
{
	namespace MergeTwoBinaryTrees
	{
		TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
			if (!root1 || !root2) { return root1 ? root1 : root2; }

			TreeNode* newNode = new TreeNode(root1-&gt;val + root2-&gt;val);
			newNode-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);
			newNode-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);
			return newNode;
		}

		TreeNode* mergeTreesIterative(TreeNode* root1, TreeNode* root2) {
			if (!root1 || !root2) { return root1 ? root1 : root2; }
			
			stack&lt;pair&lt;TreeNode*, TreeNode*&gt;&gt; s;
			s.push({root1, root2});

			while (!s.empty()) {
				pair&lt;TreeNode*, TreeNode*&gt; top = s.top();
				s.pop();
				TreeNode* n1 = top.first;
				TreeNode* n2 = top.second;
				
				n1-&gt;val += n2-&gt;val;
				if (!n1-&gt;left && n2-&gt;left) { n1-&gt;left = n2-&gt;left; }
				else if (n1-&gt;left && n2-&gt;left) { s.push({n1-&gt;left, n2-&gt;left}); }
				if (!n1-&gt;right && n2-&gt;right) { n1-&gt;right = n2-&gt;right; }
				else if (n1-&gt;right && n2-&gt;right) { s.push({n1-&gt;right, n2-&gt;right}); }
			}
			return root1;
		}


		void Main() {
			string test = "tst test test";
			print(test);
		}
	}
}

	</code>
	</pre>
	</figure>
	
	</body>
	</html>
	