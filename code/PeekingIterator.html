<!doctype html>
	<html>
	<head>
	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-151395790-1"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'UA-151395790-1');
	</script>	
	<title>PeekingIterator</title>
	<!-- Latest compiled and minified CSS -->
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu" crossorigin="anonymous">

	<!-- Optional theme -->
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap-theme.min.css" integrity="sha384-6pzBo3FDv/PJ8r2KRkGHifhEocL+1X2rVCTTkUfGk7/0pbek5mMa1upzvWbrUbOZ" crossorigin="anonymous">

	<!-- Latest compiled and minified JavaScript -->
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd" crossorigin="anonymous"></script>

	<link rel="stylesheet" href="../web/codepage.css" />
	</head>
	<body>
	<h1>PeekingIterator</h1>
	
	<figure class="highlight">
	<pre>
	<code class="language-html">
#include "stdafx.h"

//Design an iterator that supports the peek operation on an existing iterator in
//addition to the hasNext and the next operations.
//Implement the PeekingIterator class:
//PeekingIterator(Iterator&lt;int&gt; nums) Initializes the object with the given
//integer iterator iterator.
//int next() Returns the next element in the array and moves the pointer to the
//next element.
//boolean hasNext() Returns true if there are still elements in the array.
//int peek() Returns the next element in the array without moving the pointer.
//
//Note: Each language may have a different implementation of the constructor and
//Iterator, but they all support the int next() and boolean hasNext() functions.
// 
//
//Example 1:
//Input
//["PeekingIterator", "next", "peek", "next", "next", "hasNext"]
//
[
[
[1, 2, 3]
], 
[], 
[], 
[], 
[], 
[]
]
//Output
//[null, 1, 2, 2, 3, false]
//Explanation
//PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]
//peekingIterator.next();    // return 1, the pointer moves to the next element
//[1,2,3].
//peekingIterator.peek();    // return 2, the pointer does not move [1,2,3].
//peekingIterator.next();    // return 2, the pointer moves to the next element
//[1,2,3]
//peekingIterator.next();    // return 3, the pointer moves to the next element
//[1,2,3]
//peekingIterator.hasNext(); // return False
// 
//Constraints:
//1 &lt;= nums.length &lt;= 1000
//1 &lt;= nums[i] &lt;= 1000
//All the calls to next and peek are valid.
//At most 1000 calls will be made to next, hasNext, and peek.
// 
//Follow up: How would you extend your design to be generic and work with all
//types, not just integer?

namespace Solution2022
{
	namespace PeekingIterator
	{
		/*
		 * Below is the interface for Iterator, which is already defined for you.
		 * **DO NOT** modify the interface for Iterator.
		 *
		 *  class Iterator {
		 *      struct Data;
		 *      Data* data;
		 *  public:
		 *      Iterator(const vector&lt;int&gt;& nums);
		 *      Iterator(const Iterator& iter);
		 *
		 *      // Returns the next element in the iteration.
		 *      int next();
		 *
		 *      // Returns true if the iteration has more elements.
		 *      bool hasNext() const;
		 *  };
		 */

		class PeekingIterator : public Iterator {
		private:
			int nextV;
			bool hasNextV;
		public:
			PeekingIterator(const vector&lt;int&gt;& nums) : Iterator(nums) {
				hasNextV = Iterator::hasNext();
				if (hasNextV) { nextV = Iterator::next(); }
			}

			// Returns the next element in the iteration without advancing the iterator.
			int peek() {
				return nextV;
			}

			// hasNext() and next() should behave the same as in the Iterator interface.
			// Override them if needed.
			int next() {
				int result = nextV;
				hasNextV = Iterator::hasNext();
				if (hasNextV) { nextV = Iterator::next(); }
				return result;
			}

			bool hasNext() const {
				return hasNextV;
			}
		};

		void Main() {
			string test = "tst test test";
			print(test);
		}
	}
}

	</code>
	</pre>
	</figure>
	
	</body>
	</html>
	